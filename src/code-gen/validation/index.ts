import { log } from "../../insight";
import { makeError } from "./errors";
import {
  booleanGenerateType,
  booleanGenerateValidation,
  booleanSetDefaults,
  BooleanValidation,
} from "./rules/boolean";
import {
  numberGenerateType,
  numberGenerateValidation,
  numberSetDefaults,
  NumberValidation,
} from "./rules/number";
import {
  stringGenerateType,
  stringGenerateValidation,
  stringSetDefaults,
  StringValidation,
} from "./rules/string";

export type ValidationSchema = {
  [s: string]: StringValidation | NumberValidation | BooleanValidation;
};

/**
 * Strict enforces that only known keys may be provided
 */
export interface ValidationOptions {
  strict?: boolean;
}

const generators = {
  string: {
    defaults: stringSetDefaults,
    types: stringGenerateType,
    validations: stringGenerateValidation,
  },
  number: {
    defaults: numberSetDefaults,
    types: numberGenerateType,
    validations: numberGenerateValidation,
  },
  boolean: {
    defaults: booleanSetDefaults,
    types: booleanGenerateType,
    validations: booleanGenerateValidation,
  },
};

export function optsSetDefaults(opts: ValidationOptions) {
  opts.strict = opts.strict === undefined ? true : opts.strict;
}

export function schemaSetDefaults(schema: ValidationSchema) {
  Object.values(schema).forEach(it => {
    generators[it.type].defaults(it as any);
  });
}

/**
 * Provide the necessary imports for generated content
 * TODO: Fix import
 */
export function getBaseValidatorOutput(): string {
  return `
// GENERATED BY @lightbase/code-gen

import { isNil } from "@lightbase/stdlib";
`;
}

export function generateValidator(
  name: string,
  schema: ValidationSchema,
  opts: ValidationOptions,
) {
  const tsInterface = generateInterface(name, schema);
  const func = generateValdiatorFunc(name, schema, opts);

  log.info(`${tsInterface}\n\n${func}`);

  return `${tsInterface}\n\n${func}`;
}

function generateInterface(name: string, schema: ValidationSchema): string {
  const src = [`export interface ${name} {`];

  Object.entries(schema).forEach(([key, value]) => {
    src.push(generators[value.type].types(key, value as any));
  });

  src.push("}");
  return src.join("\n");
}
function generateValdiatorFunc(
  name: string,
  schema: ValidationSchema,
  opts: ValidationOptions,
): string {
  const src = [
    `export function validate${name}(data: any): ${name} {`,
    "if (data === null) {",
    makeError("base.null"),
    "}",
    `if (typeof data !== "object") {`,
    makeError("base.object"),
    "}",
  ];

  if (opts.strict) {
    src.push(`const entries = Object.keys(data);`);
  }

  Object.entries(schema).forEach(([key, value]) => {
    const validationSrc = generators[value.type].validations(key, value as any);
    src.push(validationSrc, "");

    if (opts.strict) {
      src.push(`entries.splice(entries.indexOf("${key}"), 1);`);
    }
  });

  if (opts.strict) {
    src.push(`if (entries.length > 0) {`, makeError("strict"), "}");
  }

  src.push(`return data as ${name};`, "}");
  return src.join("\n");
}
