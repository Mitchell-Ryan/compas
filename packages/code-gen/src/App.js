import { newLogger, printProcessMemoryUsage } from "@lbu/insight";
import { isNil, isPlainObject, newTemplateContext } from "@lbu/stdlib";
import { existsSync, promises } from "fs";
import path from "path";
import { isNamedTypeBuilderLike, TypeCreator } from "./types/index.js";
import { lowerCaseFirst, upperCaseFirst } from "./utils.js";

const { writeFile, mkdir } = promises;

/**
 * @typedef {object} AppOpts
 * @property {GeneratorPlugin[]} generators
 * @property {boolean} [verbose]
 */

/**
 * @typedef {object} GeneratorPlugin
 * @property {string} name
 * @property {function(App): void|Promise<void>} [init]
 * @property {function(App, GenerateOptions): void|Promise<void>} [preGenerate]
 * @property {function(App, GenerateOptions, object):
 *   GeneratedFile[]|GeneratedFile|Promise<GeneratedFile[]|GeneratedFile>} [generate]
 */

/**
 * @typedef {object} GenerateOptions
 * @property {boolean} [useTypescript]
 * @property {string} [fileHeader]
 * @property {string} outputDirectory
 */

/**
 * @typedef {object} GeneratedFile
 * @property {string} path
 * @property {string} source
 */

/**
 * @class
 */
export class App {
  /**
   * @param {AppOpts} options
   */
  constructor({ verbose, generators }) {
    /**
     * @public
     * @type {Map<string, GeneratorPlugin>}
     */
    this.generators = new Map();

    this.fileHeader = `// Generated by @lbu/code-gen at ${new Date().toISOString()}
/* eslint-disable no-unused-vars */
`;

    /**
     * @public
     * @type {boolean}
     */
    this.verbose = verbose || false;

    /**
     * @public
     * @type {Logger}
     */
    this.logger = newLogger({
      ctx: {
        type: "code_gen",
      },
      depth: 8,
    });

    /**
     * @public
     * @type {TemplateContext}
     */
    this.templateContext = newTemplateContext();

    /** @type {Set<TypeBuilder>} */
    this.unprocessedData = new Set();

    /** @type {{structure: object<key, object<key, object>>}} */
    this.data = {
      structure: {},
    };

    this._generatorList = generators;
  }

  /**
   * Init generators and validate types
   * @return {Promise<void>}
   */
  async init() {
    this.templateContext.globals["upperCaseFirst"] = upperCaseFirst;
    this.templateContext.globals["lowerCaseFirst"] = lowerCaseFirst;

    for (const g of this._generatorList) {
      if (isNil(g.name)) {
        throw new Error("Generator is missing name");
      }

      this.generators.set(g.name, g);
    }

    if (this.verbose) {
      this.logger.info("registered plugins: ", {
        generators: [...this.generators.keys()],
        types: [...TypeCreator.types.keys()],
      });
    }

    await this.callGeneratorMethod("init");
  }

  /**
   * @public
   * @param {...TypeBuilder} builders
   * @return {this}
   */
  add(...builders) {
    for (const builder of builders) {
      this.unprocessedData.add(builder);
    }

    return this;
  }

  /**
   * @public
   * @param data
   */
  extend(data) {
    if (!isPlainObject(data?.structure)) {
      throw new Error(`data.structure should be an object.`);
    }

    for (const groupData of Object.values(data.structure)) {
      for (const item of Object.values(groupData)) {
        this.addToData(item);
      }
    }
  }

  /**
   * Run the generate methods on the plugins
   * Uses dump internally
   * @param {GenerateOptions} options
   */
  async generate(options) {
    if (isNil(options?.outputDirectory)) {
      throw new Error("Need options.outputDirectory to write files to.");
    }
    options.fileHeader = this.fileHeader + (options.fileHeader ?? "");
    options.useTypescript = !!options.useTypescript;

    await this.callGeneratorMethod("preGenerate", options);
    this.processData();

    const generatorInput = JSON.parse(JSON.stringify(this.data));
    const result = await this.callGeneratorMethod(
      "generate",
      options,
      generatorInput,
    );

    await this.normalizeAndWriteFiles(options, result);

    printProcessMemoryUsage(this.logger);
  }

  async generateStubs() {
    await this.callGeneratorMethod("preGenerateStubs");
    this.processData();
  }

  /**
   * @private
   * Call a method on all known generator plugins
   * Will pass this as the first argument
   * @param {string} method
   * @param {...*} args
   */
  async callGeneratorMethod(method, ...args) {
    const result = [];

    for (const generator of this.generators.values()) {
      if (method in generator) {
        if (this.verbose) {
          this.logger.info(`generator: calling ${method} on ${generator.name}`);
        }
        result.push(await generator[method](this, ...args));
      }
    }

    return result;
  }

  /**
   * @private
   * @param {GenerateOptions} options
   * @param {(GeneratedFile|GeneratedFile[])[]} files
   */
  async normalizeAndWriteFiles(options, files) {
    const flattenedFiles = [];

    for (const file of files) {
      if (!Array.isArray(file)) {
        flattenedFiles.push(file);
      } else {
        flattenedFiles.push(...file);
      }
    }

    if (!existsSync(options.outputDirectory)) {
      await mkdir(options.outputDirectory, { recursive: true });
    }

    for (const file of flattenedFiles) {
      const filePath = path.join(options.outputDirectory, file.path);
      await writeFile(filePath, file.source, { encoding: "utf-8" });
    }
  }

  /**
   * @private
   * Process unprocessed list, normalize references
   * Depends on referentType being available
   */
  processData() {
    for (const item of this.unprocessedData) {
      const result = item.build();
      this.addToData(result);
    }
    this.unprocessedData.clear();

    for (const group of Object.values(this.data.structure)) {
      for (const item of Object.values(group)) {
        this.normalizeDataRecursively(item);
      }
    }
  }

  /**
   * @private
   * @param item
   */
  addToData(item) {
    if (!item.group || !item.name || !item.type) {
      throw new Error(
        `Can't process item. Missing either group, name or type. Found: ${JSON.stringify(
          item,
        )}`,
      );
    }

    if (!this.data.structure[item.group]) {
      this.data.structure[item.group] = {};
    }
    this.data.structure[item.group][item.name] = item;

    item.uniqueName = upperCaseFirst(item.group) + upperCaseFirst(item.name);
  }

  /**
   * @private
   * On the way down, register unknown named models
   * On the way up, replace anything that is named with a reference type
   * @param value
   */
  normalizeDataRecursively(value) {
    if (isNil(value) || (!isPlainObject(value) && !Array.isArray(value))) {
      // Skip primitives & null / undefined
      return;
    }

    if (isNamedTypeBuilderLike(value)) {
      // Most likely valid output from TypeBuilder
      // Just overwrite it
      this.addToData(value);
    }

    if (isPlainObject(value)) {
      for (const key of Object.keys(value)) {
        this.normalizeDataRecursively(value[key]);
        if (isNamedTypeBuilderLike(value[key])) {
          // value[key] got a uniqueName when called with this.addToData()
          value[key] = {
            type: "reference",
            docString: "",
            isOptional: false,
            reference: {
              group: value[key].group,
              name: value[key].name,
              uniqueName: value[key].uniqueName,
            },
          };
        }
      }
    } else if (Array.isArray(value)) {
      for (let i = 0; i < value.length; ++i) {
        this.normalizeDataRecursively(value[i]);
        if (isNamedTypeBuilderLike(value[i])) {
          // value[i] got a uniqueName when called with this.addToData()
          value[i] = {
            type: "reference",
            docString: "",
            isOptional: false,
            reference: {
              group: value[i].group,
              name: value[i].name,
              uniqueName: value[i].uniqueName,
            },
          };
        }
      }
    }
  }
}
