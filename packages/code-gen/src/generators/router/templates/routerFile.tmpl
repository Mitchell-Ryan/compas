{{= options.fileHeader }}
((newline))

import { compose } from "@lbu/server";
import { AppError } from "@lbu/stdlib";
import {
{{ for (const group of Object.keys(structure)) { }}
{{= group }}Validators,
{{ } }}
} from "./validators.js";
((newline))

let _internalBodyParser = undefined;
export function setBodyParser(parser) {
  _internalBodyParser = ctx => new Promise(r => parser(ctx, r).then(r));
}
((newline))

function parseBody(ctx) {
    return _internalBodyParser(ctx);
}
((newline))

const filterCompose = (...args) => compose(args.filter(it => it !== undefined));
((newline))

export const tagMiddleware = {
  {{ for (const t of routeTags) { }}
    {{= t }}: undefined,
  {{ } }}
};
((newline))

export const groupMiddleware = {
  {{ for (const group of Object.keys(structure)) { }}
    {{= group }}: undefined,
  {{ } }}
};
((newline))

const _composed = {
  {{ for (const groupName of Object.keys(structure)) { }}
    {{ for (const itemName of Object.keys(structure[groupName])) { }}
      {{ const item = structure[groupName][itemName]; }}

      {{ if (item.type !== "route") { }}
      {{ continue; }}
      {{ } }}

      {{= item.uniqueName }}: undefined,

    {{ } }}
  {{ } }}
};
((newline))

const handlers = {
  {{ for (const groupName of Object.keys(structure)) { }}
    {{ for (const itemName of Object.keys(structure[groupName])) { }}
      {{ const item = structure[groupName][itemName]; }}

      {{ if (item.type !== "route") { }}
      {{ continue; }}
      {{ } }}
((newline))

      {{= item.uniqueName }}: {{ if (item.body || item.query) { }} async {{ } }} function (params, ctx, next) {

        ctx.request.params = params;

        {{ if (item.params && item.params.reference) { }}
        ctx.validatedParams = {{= item.params.reference.group }}Validators.{{= item.params.reference.name }}(params);
        {{ } }}

        {{ if (item.body || item.query) { }}
        await parseBody(ctx);
        {{ } }}

        {{ if (item.query) { }}
        ctx.validatedQuery = {{= item.query.reference.group }}Validators.{{= item.query.reference.name }}(ctx.request.query);
        {{ } }}

        {{ if (item.body) { }}
        ctx.validatedBody = {{= item.body.reference.group }}Validators.{{= item.body.reference.name }}(ctx.request.body);
        {{ } }}

        if (_composed.{{= item.uniqueName }} === undefined) {
          const currentHandler = {{= item.group }}Handlers.{{= item.name }};
          _composed.{{= item.uniqueName }} = filterCompose(
              {{ for (const t of item.tags) { }}
              tagMiddleware.{{= t }},
              {{ } }}
              groupMiddleware.{{= item.group }},
              ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
          );
        }

        return _composed.{{= item.uniqueName }}(ctx, next);
      },

    {{ } }}
  {{ } }}
};
((newline))

{{ for (const groupName of Object.keys(structure)) { }}
  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (item.type !== "route") { }}
    {{ continue; }}
    {{ } }}

    /**
     * @name {{= item.uniqueName }}Ctx
     * @typedef {object & Application}
     * @property {Logger} log
     {{ if (item.response) { }}* @property { {{= item.response.reference.uniqueName }} } body {{ } }}
     {{ if (item.query) { }}* @property { {{= item.query.reference.uniqueName }} } validatedQuery {{ } }}
     {{ if (item.params) { }}* @property { {{= item.params.reference.uniqueName }} } validatedParams {{ } }}
     {{ if (item.body) { }}* @property { {{= item.body.reference.uniqueName }} } validatedBody {{ } }}
     */
((newline))
     /**
       * @callback {{= item.uniqueName }}Fn
       * @param { {{= item.uniqueName }}Ctx} ctx
       * @param {Function} next
       * @returns {void|Promise<void>}
       */
((newline))

  {{ } }}
{{ } }}

{{ for (const groupName of Object.keys(structure)) { }}

  /**
   * @type { {
   {{ for (const itemName of Object.keys(structure[groupName])) { }}
       {{ const item = structure[groupName][itemName]; }}

       {{ if (item.type !== "route") { }}
       {{ continue; }}
       {{ } }}

   * {{= item.name }}: ({{= item.uniqueName }}Fn|{{= item.uniqueName }}Fn[]),

   {{ } }}

   * } }
   */
  export const {{= groupName }}Handlers = {
((newline))

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (item.type !== "route") { }}
    {{ continue; }}
    {{ } }}

    /**
     * {{= item.docString.replace(/\n/g, "\n  * ") }}
     * Tags: {{= item.tags.join(", ") }}
     * {{= item.method }} {{= item.path }}
     */
     {{= item.name }}: (ctx, next) => {
       throw AppError.notImplemented();
     },
((newline))

  {{ } }}

  };
((newline))

{{ } }}


{{ const context = { functions: "", counter: 0 }; }}
((newline))

export function router(ctx, next) {
  let triePath = ctx.method + ctx.path;
  if (triePath.endsWith("/")) {
    triePath = triePath.substring(0, triePath.length - 1);
  }

  const params = Object.create(null);
  let route = undefined;

  {{ for (const child of routeTrie.children) { }}
  route = routeMatcher{{= context.counter }}(triePath, params, 0);
  {{ const src = routeMatcher({ matcher: child, context }); }}
  {{ context.functions += src; }}
  if (route !== undefined) {
    return route(params, ctx, next);
  }
  {{ } }}

  return next();
}
((newline))

lbuHandlers.structure = (ctx, next) => {
  ctx.set("Content-Type", "application/json");
  ctx.body = '{{= stringified }}';

  return next();
}
((newline))


{{= context.functions }}
((newline))
