{{= options.fileHeader }}

import { compose, AppError } from "@lbu/server";
import {
{{ for (const group of Object.keys(structure)) { }}
{{= group }}Validators,
{{ } }}
} from "./validators.js";

let _internalBodyParser = undefined;
export function setBodyParser(parser) {
  _internalBodyParser = ctx => new Promise(r => parser(ctx, r).then(r));
}

function parseBody(ctx) {
    return _internalBodyParser(ctx);
}

const filterCompose = (...args) => compose(args.filter(it => it !== undefined));

export const tagMiddleware = {
  {{ for (const t of routeTags) { }}
    {{= t }}: undefined,
  {{ } }}
};

export const groupMiddleware = {
  {{ for (const group of Object.keys(structure)) { }}
    {{= group }}: undefined,
  {{ } }}
};

const _composed = {
  {{ for (const groupName of Object.keys(structure)) { }}
    {{ for (const itemName of Object.keys(structure[groupName])) { }}
      {{ const item = structure[groupName][itemName]; }}

      {{ if (item.type !== "route") { }}
      {{ continue; }}
      {{ } }}

      {{= item.uniqueName }}: undefined,

    {{ } }}
  {{ } }}
};

const handlers = {
  {{ for (const groupName of Object.keys(structure)) { }}
    {{ for (const itemName of Object.keys(structure[groupName])) { }}
      {{ const item = structure[groupName][itemName]; }}

      {{ if (item.type !== "route") { }}
      {{ continue; }}
      {{ } }}

      {{= item.uniqueName }}: {{ if (item.body || item.query) { }} async {{ } }} function (params, ctx, next) {

        ctx.request.params = params;

        {{ if (item.params && item.params.reference) { }}
        ctx.validatedParams = {{= item.params.reference.group }}Validators.{{= item.params.reference.name }}(params);
        {{ } }}

        {{ if (item.body || item.query) { }}
        await parseBody(ctx);
        {{ } }}

        {{ if (item.query) { }}
        ctx.validatedQuery = {{= item.query.reference.group }}Validators.{{= item.query.reference.name }}(ctx.request.query);
        {{ } }}

        {{ if (item.body) { }}
        ctx.validatedBody = {{= item.body.reference.group }}Validators.{{= item.body.reference.name }}(ctx.request.body);
        {{ } }}

        if (_composed.{{= item.uniqueName }} === undefined) {
          const currentHandler = {{= item.group }}Handlers.{{= item.name }};
          _composed.{{= item.uniqueName }} = filterCompose(
              {{ for (const t of item.tags) { }}
              tagMiddleware.{{= t }},
              {{ } }}
              groupMiddleware.{{= item.group }},
              ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
          );
        }

        return _composed.{{= item.uniqueName }}(ctx, next);
      },

    {{ } }}
  {{ } }}
};

{{ for (const groupName of Object.keys(structure)) { }}

  export const {{= groupName }}Handlers = {

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (item.type !== "route") { }}
    {{ continue; }}
    {{ } }}

    /**
     * {{= item.docString.replace(/\n/g, "\\n  * ") }}
     * Tags: {{= item.tags.join(", ") }}
     * {{= item.method }} {{= item.path }}
     * @param {object} ctx
     {{ if (item.response) { }}* @param { {{= item.response.reference.uniqueName }} } ctx.body {{ } }}
     {{ if (item.query) { }}* @param { {{= item.query.reference.uniqueName }} } ctx.validatedQuery {{ } }}
     {{ if (item.params) { }}* @param { {{= item.params.reference.uniqueName }} } ctx.validatedParams {{ } }}
     {{ if (item.body) { }}* @param { {{= item.body.reference.uniqueName }} } ctx.validatedBody {{ } }}
     * @param {Function} next
     * @returns {void|Promise<void>}
     */
     {{= item.name }}: (ctx, next) => {
       throw AppError.notImplemented();
     },

  {{ } }}

  };

{{ } }}


{{ const context = { functions: "", counter: 0 }; }}

export function router(ctx, next) {
  let triePath = ctx.method + ctx.path;
  if (triePath.endsWith("/")) {
    triePath = triePath.substring(0, triePath.length - 1);
  }

  const params = Object.create(null);
  let route = undefined;

  {{ for (const child of routeTrie.children) { }}
  route = routeMatcher{{= context.counter }}(triePath, params, 0);
  {{ const src = routeMatcher({ matcher: child, context }); }}
  {{ context.functions += src; }}
  if (route !== undefined) {
    return route(params, ctx, next);
  }
  {{ } }}

  return next();
}

lbuHandlers.structure = (ctx, next) => {
  ctx.set("Content-Type", "application/json");
  ctx.body = "{{= stringified.replace(/"/g, "\\\"") }}";

  return next();
}


{{= context.functions }}
