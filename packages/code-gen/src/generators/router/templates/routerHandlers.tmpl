let _internalBodyParser = undefined;
function parseBody(ctx) {
    if (_internalBodyParser === undefined) {
      const bp = getBodyParser();
      _internalBodyParser = ctx => new Promise(r => bp(ctx, r).then(r));
    }

    return _internalBodyParser(ctx);
}

const filterCompose = (...args) => compose(args.filter(it => it !== undefined));

const _composed = {
{{ for (const r of routes) { }}
{{ const qName = r.group + "_" + r.name; }}
  {{= qName }}: undefined,
{{ } }}
};

const handlers = {
{{ for (const r of routes) { }}
{{ const qName = r.group + "_" + r.name; }}
  {{= qName }}: {{ if (r.bodyValidator || r.queryValidator) { }} async {{ } }} function (params, ctx, next) {
    ctx.request.params = params;

    {{ if (r.paramsValidator) { }}
    ctx.validatedParams = validate{{= r.paramsValidator }}(params);
    {{ } }}

    {{ if (r.bodyValidator || r.queryValidator) { }}
    await parseBody(ctx);
    {{ } }}

    {{ if (r.bodyValidator) { }}
    ctx.validatedBody = validate{{= r.bodyValidator }}(ctx.request.body);
    {{ } }}

    {{ if (r.queryValidator) { }}
    ctx.validatedQuery = validate{{= r.queryValidator }}(ctx.request.query);
    {{ } }}

    if (_composed.{{= qName }} === undefined) {
      const curHandler = {{= r.group }}Handlers.{{= r.name }};
      _composed.{{= qName }} = filterCompose(
        {{ for (const t of r.tags) { }}
          taggedMiddleware.{{= t }},
        {{ } }}
          groupMiddleware.{{= r.group }},
        ...(Array.isArray(curHandler) ? curHandler : [curHandler]),
      );
    }

    return _composed.{{= qName }}(ctx, next);
  },
{{ } }}
};

{{ for (const group of routeGroups) { }}
export const {{= group }}Handlers = {
{{ for (const r of routes) { }}
{{ if (r.group !== group) { continue; } }}
  /**
   * {{= r.docs.replace(/\n/g, "\\n  * ") }}
   * Tags: {{= r.tags.join(", ") }}
   * {{= r.method}} {{= r.path }}
   * @param {Object} ctx
   {{ if (r.responseModel) { }}
   * @param { {{= r.responseModel }} } ctx.body
   {{ } }}
   {{ if (r.queryValidator) { }}
   * @param { {{= r.queryValidator }} } ctx.validatedQuery
   {{ } }}
  {{ if (r.paramsValidator) { }}
  * @param { {{= r.paramsValidator }} } ctx.validatedParams
  {{ } }}
  {{ if (r.bodyValidator) { }}
  * @param { {{= r.bodyValidator }} } ctx.validatedBody
  {{ } }}
   * @param {Function} next
   * @returns {void|Promise<void>}
  */
  {{= r.name }}: (ctx, next) => {
    throw AppError.notImplemented();
  },
{{ } }}
};
{{ } }}
