{{ const fnNumber = ctx.anonFn(item); }}

/**
 * {{= item.docString }}
 * @param {*} value
 * @param {string} [propertyPath]
 {{ if (!options.validatorCollectErrors) { }}
 * @returns { {{= options.useTypescript ? `import("./types").${item.uniqueName}` : item.uniqueName }}}
 {{ } else { }}
 * @returns { { errors: ({ key: string, info: object}[]|undefined), data: {{= options.useTypescript ? `import("./types").${item.uniqueName}` : item.uniqueName }}|undefined } }
 {{ } }}
 */
{{= lowerCaseFirst(item.name) }}: (value, propertyPath = "$") => {
 let result = value;

 {{ const preValidate = quote("preValidate" + item.uniqueName); }}
 {{ const postValidate = quote("postValidate" + item.uniqueName); }}
 if ({{= preValidate }} in validatorHooks) {
    result = validatorHooks[{{= preValidate }}](result);
 }

{{ if (!options.validatorCollectErrors) { }}
result =  {{= item.type }}Validator{{= fnNumber }}(result, propertyPath);
if ({{= postValidate }} in validatorHooks) {
    return validatorHooks[{{= postValidate }}](result);
 } else {
   return result;
 }
{{ } else { }}

const errorList = [];
result = {{= item.type }}Validator{{= fnNumber }}(result, propertyPath, errorList, "{{= item.type }}");

if (errorList.length > 0) {
  return { errors: errorList };
} else {
  if ({{= postValidate }} in validatorHooks) {
      return validatorHooks[{{= postValidate }}]({ data: result });
   } else {
     return { data: result };
   }
}
{{ } }}
((newline))
},
((newline))
