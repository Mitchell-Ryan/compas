{{= options.fileHeader }}
((newline))

export const validatorHooks = {};
((newline))

const isNil = value => value === undefined || value === null;
((newline))

/**
 * This function should not throw as the corresponding validator will do that
 * @callback ValidationErrorFn
 * @param {string} key
 * @param {Object} info
 */
((newline))

/**
 * @type ValidationErrorFn
 */
let _errorBuildFn = (key, info) => {
  const err = new Error(`ValidationError: ${key}`);
  err.key = key;
  err.info = info;

  return err;
}
((newline))

/**
 * Set a different error function, for example AppError.validationError
 * @param {ValidationErrorFn} fn
 */
export function validatorSetError(fn) {
  _errorBuildFn = fn;
}
((newline))

{{ if (!options.validatorCollectErrors) { }}
function buildError(key, info) {
  throw _errorBuildFn(key, info);
}
{{ } else { }}
function buildError(key, info, list) {
  list.push(_errorBuildFn(key, info));
  return undefined;
}
{{ } }}
((newline))

{{ const ctx = { counter: 0, functions: [], memo: new Map() }; }}
{{ ctx.addFunc = fn => { ctx.functions.push(fn); }; }}
{{ ctx.anonFn = (model) => { const key = inspect(model); if (!ctx.memo.has(key)) { const nr = ctx.counter; ctx.addFunc(validatorsAnonFn({ model, ctx, options })); ctx.memo.set(key, nr); } return ctx.memo.get(key); }; }}

{{ for (const groupName of Object.keys(structure)) { }}

  export const {{= groupName }}Validators = {
((newline))

  {{ for (const itemName of Object.keys(structure[groupName])) { }}
    {{ const item = structure[groupName][itemName]; }}

    {{ if (options.validator_enabledTypes.indexOf(item.type) === -1) { }}
    {{ continue; }}
    {{ } }}

    {{= validatorsNamedFn({ ctx, model: item, options }) }}
((newline))

  {{ } }}

  };
((newline))

{{ } }}

{{= ctx.functions.join("\n") }}
((newline))
