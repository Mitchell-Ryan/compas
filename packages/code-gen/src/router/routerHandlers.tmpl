let _internalBodyParser = undefined;
const parseBody = ctx => {
    if (_internalBodyParser === undefined) {
      const bp = getBodyParser();
      _internalBodyParser = ctx => new Promise(r => bp(ctx, r).then(r));
    }

    return _internalBodyParser(ctx);
}

const handlers = {
{{ for (const r of routes) { }}
  {{= r.name }}: async (params, ctx, next) => {
    ctx.request.params = params;

    {{ if (r.paramsValidator) { }}
    ctx.validatedParams = {{= r.paramsValidator.funcName }}(params);
    {{ } }}

    {{ if (r.bodyValidator || r.queryValidator) { }}
    await parseBody(ctx);
    {{ } }}

    {{ if (r.bodyValidator) { }}
    ctx.validatedBody = {{= r.bodyValidator.funcName }}(ctx.request.body);
    {{ } }}

    {{ if (r.queryValidator) { }}
    ctx.validatedQuery = {{= r.queryValidator.funcName }}(ctx.request.body);
    {{ } }}

    return routeHandlers.{{= r.name }}(ctx, next);
  },
{{ } }}
};

const routeHandlers = {
{{ for (const r of routes) { }}
  /**
   * {{= r.docs.replace(/\n/g, "\\n  * ") }}
   * Tags: {{= r.tags.join(", ") }}
   * {{= r.method}} {{= r.path }}
   * @param {Object} ctx
   {{ if (r.queryValidator) { }}
   * @param { {{= r.queryValidator.typeName }} } ctx.validatedQuery
   {{ } }}
  {{ if (r.paramsValidator) { }}
  * @param { {{= r.paramsValidator.typeName }} } ctx.validatedParams
  {{ } }}
  {{ if (r.bodyValidator) { }}
  * @param { {{= r.bodyValidator.typeName }} } ctx.validatedBody
  {{ } }}
   * @param {Function} next
   * @returns {void|Promise<void>}
  */
  {{= r.name }}: (ctx, next) => next(),
{{ } }}
};
