// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { compose } from "@compas/server";
import { AppError, eventRename } from "@compas/stdlib";
import { compasHandlers } from "../compas/controller.js";
import * as compasValidators from "../compas/validators.js";
import { todoHandlers } from "../todo/controller.js";
import * as todoValidators from "../todo/validators.js";
import { compasApiStructureString } from "./structure.js";

let internalBodyParsers = undefined;
/**
 * @param {BodyParserPair} parsers
 */
export function setBodyParsers(parsers) {
  internalBodyParsers = {
    body: parsers.bodyParser,
    files: parsers.multipartBodyParser,
  };
}

const filterCompose = (...args) =>
  compose(args.filter((it) => it !== undefined));

const decodePathParam = (arg) => {
  try {
    return decodeURIComponent(arg);
  } catch (e) {
    throw AppError.validationError("router.param.invalidEncoding", {
      param: arg,
    });
  }
};
/**
 * @typedef GroupMiddleware
 * @property {CMiddleware|CMiddleware[]|undefined} compas
 * @property {CMiddleware|CMiddleware[]|undefined} todo
 */
/**
 * @type {GroupMiddleware}
 */
export const groupMiddleware = {
  compas: undefined,
  todo: undefined,
};

const _composed = {
  CompasStructure: undefined,
  TodoAdd: undefined,
  TodoComplete: undefined,
  TodoList: undefined,
  TodoSingle: undefined,
};

/**
 * Clear composed handlers.
 *
 * All handlers are composed via a koa-compose like and then memoized. When overwriting an
 * handler when the route is already called, the overwritten handlers will not be
 * executed till this function is called.
 */
export function routerClearMemoizedHandlers() {
  for (const key of Object.keys(_composed)) {
    _composed[key] = undefined;
  }
}

const handlers = {
  CompasStructure: (params, ctx, next) => {
    if (ctx.event) {
      eventRename(ctx.event, `router.compas.structure`);
    }
    ctx.request.params = params;
    if (_composed.CompasStructure === undefined) {
      const currentHandler = compasHandlers.structure;
      _composed.CompasStructure = filterCompose(
        ...(Array.isArray(groupMiddleware.compas)
          ? groupMiddleware.compas
          : [groupMiddleware.compas]),
        ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
      );
    }
    return _composed.CompasStructure(ctx, next);
  },

  TodoAdd: async (params, ctx, next) => {
    if (ctx.event) {
      eventRename(ctx.event, `router.todo.add`);
    }
    ctx.request.params = params;
    await internalBodyParsers.body(ctx);
    const validatedBody = todoValidators.validateTodoItemPick(ctx.request.body);
    if (validatedBody.error) {
      throw validatedBody.error;
    }
    ctx.validatedBody = validatedBody.value;
    if (_composed.TodoAdd === undefined) {
      const currentHandler = todoHandlers.add;
      _composed.TodoAdd = filterCompose(
        ...(Array.isArray(groupMiddleware.todo)
          ? groupMiddleware.todo
          : [groupMiddleware.todo]),
        ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
      );
    }
    return _composed.TodoAdd(ctx, next);
  },

  TodoComplete: (params, ctx, next) => {
    if (ctx.event) {
      eventRename(ctx.event, `router.todo.complete`);
    }
    ctx.request.params = params;
    const validatedParams = todoValidators.validateTodoCompleteParams(params);
    if (validatedParams.error) {
      throw validatedParams.error;
    }
    ctx.validatedParams = validatedParams.value;
    if (_composed.TodoComplete === undefined) {
      const currentHandler = todoHandlers.complete;
      _composed.TodoComplete = filterCompose(
        ...(Array.isArray(groupMiddleware.todo)
          ? groupMiddleware.todo
          : [groupMiddleware.todo]),
        ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
      );
    }
    return _composed.TodoComplete(ctx, next);
  },

  TodoList: (params, ctx, next) => {
    if (ctx.event) {
      eventRename(ctx.event, `router.todo.list`);
    }
    ctx.request.params = params;
    if (_composed.TodoList === undefined) {
      const currentHandler = todoHandlers.list;
      _composed.TodoList = filterCompose(
        ...(Array.isArray(groupMiddleware.todo)
          ? groupMiddleware.todo
          : [groupMiddleware.todo]),
        ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
      );
    }
    return _composed.TodoList(ctx, next);
  },

  TodoSingle: (params, ctx, next) => {
    if (ctx.event) {
      eventRename(ctx.event, `router.todo.single`);
    }
    ctx.request.params = params;
    const validatedParams = todoValidators.validateTodoSingleParams(params);
    if (validatedParams.error) {
      throw validatedParams.error;
    }
    ctx.validatedParams = validatedParams.value;
    if (_composed.TodoSingle === undefined) {
      const currentHandler = todoHandlers.single;
      _composed.TodoSingle = filterCompose(
        ...(Array.isArray(groupMiddleware.todo)
          ? groupMiddleware.todo
          : [groupMiddleware.todo]),
        ...(Array.isArray(currentHandler) ? currentHandler : [currentHandler]),
      );
    }
    return _composed.TodoSingle(ctx, next);
  },
};

export function router(ctx, next) {
  let triePath = ctx.path.substring(1);
  // Also handle `/` requests
  if (!triePath.endsWith("/") && triePath.length !== 0) {
    triePath += "/";
  }
  triePath += ctx.method;
  const params = Object.create(null);
  let route = undefined;
  route = routeMatcher0(triePath, params, 0);
  if (route !== undefined) {
    return route(params, ctx, next);
  }
  route = routeMatcher1(triePath, params, 0);
  if (route !== undefined) {
    return route(params, ctx, next);
  }
  return next();
}

compasHandlers.structure = (ctx, next) => {
  ctx.set("Content-Type", "application/json");
  ctx.body = compasApiStructureString;
  return next();
};

function routeMatcher0(path, params, currentIdx) {
  if (!path.startsWith("_compas/structure.json/GET", currentIdx)) {
    return undefined;
  }
  return handlers.CompasStructure;
}
function routeMatcher2(path, params, currentIdx) {
  if (!path.startsWith("POST", currentIdx)) {
    return undefined;
  }
  return handlers.TodoAdd;
}
function routeMatcher3(path, params, currentIdx) {
  if (!path.startsWith("GET", currentIdx)) {
    return undefined;
  }
  return handlers.TodoList;
}
function routeMatcher5(path, params, currentIdx) {
  if (!path.startsWith("DELETE", currentIdx)) {
    return undefined;
  }
  return handlers.TodoComplete;
}
function routeMatcher6(path, params, currentIdx) {
  if (!path.startsWith("GET", currentIdx)) {
    return undefined;
  }
  return handlers.TodoSingle;
}
function routeMatcher4(path, params, currentIdx) {
  let subIdx = path.indexOf("/", currentIdx);
  if (subIdx === -1) {
    subIdx = path.length;
  }
  const subPath = path.substring(currentIdx, subIdx);
  const nextIdx = subIdx + 1;
  let handler = undefined;
  handler = routeMatcher5(path, params, nextIdx);
  if (handler !== undefined) {
    params.id = decodePathParam(subPath);
    return handler;
  }
  handler = routeMatcher6(path, params, nextIdx);
  if (handler !== undefined) {
    params.id = decodePathParam(subPath);
    return handler;
  }
  return undefined;
}
function routeMatcher1(path, params, currentIdx) {
  if (!path.startsWith("todo", currentIdx)) {
    return undefined;
  }
  const nextIdx = currentIdx + 1 + 4;
  let handler = undefined;
  handler = routeMatcher2(path, params, nextIdx);
  if (handler !== undefined) {
    return handler;
  }
  handler = routeMatcher3(path, params, nextIdx);
  if (handler !== undefined) {
    return handler;
  }
  handler = routeMatcher4(path, params, nextIdx);
  if (handler !== undefined) {
    return handler;
  }
  return undefined;
}
